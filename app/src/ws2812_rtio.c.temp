#include <nrfx.h>
#include <stdlib.h>
#include <sys/_stdint.h>
#include <zephyr/cache.h>
#include <zephyr/drivers/led_strip.h>
#include <zephyr/sys/barrier.h>

#include "zephyr/arch/arm/misc.h"

#define DT_DRV_COMPAT worldsemi_ws2812_rtio

#include <zephyr/drivers/counter.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/dt-bindings/led/led.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/rtio/rtio.h>
#include <zephyr/sys/util.h>
#include <zephyr/timing/timing.h>
//
#include <soc.h>
#include <zephyr/device.h>
#include <zephyr/drivers/clock_control.h>
#include <zephyr/drivers/clock_control/nrf_clock_control.h>
#include <zephyr/drivers/gpio.h>

LOG_MODULE_REGISTER(ws2812_rtio, LOG_LEVEL_DBG);

#define BIT_LEN 24
#define PULSE_WIDTH_NS 250

struct ws2812_rtio_config {
  struct gpio_dt_spec gpios;
  uint8_t num_colors;
  const uint8_t *color_mapping;
  size_t chain_length;
};

struct ws2812_rtio_data {
  struct rtio_iodev iodev;
  struct k_timer timer;
  const struct device *dev;
};

#define NOP10 \
  __ISB();    \
  arch_nop(); \
  arch_nop(); \
  arch_nop(); \
  arch_nop(); \
  arch_nop(); \
  arch_nop(); \
  arch_nop(); \
  arch_nop(); \
  arch_nop(); \
  arch_nop();

/*
 * T1H: 1 bit high pulse delay: 12 cycles == .75 usec
 * T0H: 0 bit high pulse delay: 4 cycles == .25 usec
 * TxL: inter-bit low pulse delay: 8 cycles == .5 usec
 *
 * We can't use k_busy_wait() here: its argument is in microseconds,
 * and we need roughly .05 microsecond resolution.
 */
#define DELAY_T1H NOP10 NOP10 NOP10 NOP10

#define DELAY_T0H NOP10 NOP10

/*
 * GPIO set/clear.
 *
 * We should be able to make this portable using the results of
 * https://github.com/zephyrproject-rtos/zephyr/issues/11917.
 *
 * We already have the GPIO device stashed in ws2812_gpio_config, so
 * this driver can be used as a test case for the optimized API.
 *
 * Per Arm docs, both Rd and Rn must be r0-r7, so we use the "l"
 * constraint in the below assembly.
 */
#define SET_HIGH "str %[p], [%[s], #0];" /* OUTSET = BIT(LED_PIN) */
#define SET_LOW "str %[p], [%[c], #0];"  /* OUTCLR = BIT(LED_PIN) */

// /* Send out a 1 bit's pulse */
// #define ONE_BIT(set, clear, pin)                                           \
//   __asm volatile(                                                          \
//       SET_HIGH DELAY_T1H SET_LOW DELAY_T0H ::[s] "l"(set), [c] "l"(clear), \
//       [p] "l"(pin)                                                         \
//   );

// /* Send out a 0 bit's pulse */
// #define ZERO_BIT(set, clear, pin)                                          \
//   __asm volatile(                                                          \
//       SET_HIGH DELAY_T0H SET_LOW DELAY_T1H ::[s] "l"(set), [c] "l"(clear), \
//       [p] "l"(pin)                                                         \
//   );

#define LOGIC_HIGH(set, pin) \
  __asm volatile(SET_HIGH ::[s] "l"(set), [p] "l"(pin));

/* Send out a 0 bit's pulse */
#define LOGIC_LOW(clear, pin) \
  __asm volatile(SET_LOW ::[c] "l"(clear), [p] "l"(pin));

// static void ws2812_rtio_update_rgb(const struct device *dev) {
//   LOG_DBG("Entering ws2812_rtio_update_rgb");
//   const struct ws2812_rtio_config *config = dev->config;
//   const struct ws2812_rtio_data *data = dev->data;
//   uint8_t *ptr = (uint8_t *)data->pixels;
//   size_t p;
//   // int rc;

//   /* Convert from RGB to on-wire format (e.g. GRB, GRBW, RGB, etc) */
//   for (p = 0; p < data->num_pixels; p++) {
//     uint8_t c;

//     for (c = 0; c < config->num_colors; c++) {
//       switch (config->color_mapping[c]) {
//         /* White channel is not supported by LED strip API. */
//         case LED_COLOR_ID_WHITE:
//           *ptr++ = 0;
//           break;
//         case LED_COLOR_ID_RED:
//           *ptr++ = data->pixels[p].r;
//           break;
//         case LED_COLOR_ID_GREEN:
//           *ptr++ = data->pixels[p].g;
//           break;
//         case LED_COLOR_ID_BLUE:
//           *ptr++ = data->pixels[p].b;
//           break;
//         default:
//           break;
//       }
//     }
//   }

//   // rc = send_buf(dev, (uint8_t *)pixels, num_pixels * config->num_colors);
// }

static void ws2812_rtio_update_rgb(
    const struct device *dev, struct led_rgb *pixels
) {
  const struct ws2812_rtio_config *config = dev->config;
  uint8_t *ptr = (uint8_t *)pixels;
  size_t p;

  /* Convert from RGB to on-wire format (e.g. GRB, GRBW, RGB, etc) */
  for (p = 0; p < config->chain_length; p++) {
    uint8_t c;

    for (c = 0; c < config->num_colors; c++) {
      switch (config->color_mapping[c]) {
        /* White channel is not supported by LED strip API. */
        case LED_COLOR_ID_WHITE:
          *ptr++ = 0;
          break;
        case LED_COLOR_ID_RED:
          *ptr++ = 0x55;  // pixels[p].r;
          break;
        case LED_COLOR_ID_GREEN:
          *ptr++ = 0x55;  // pixels[p].g;
          break;
        case LED_COLOR_ID_BLUE:
          *ptr++ = 0x55;  // pixels[p].b;
          break;
        default:
          break;
      }
    }
  }
}

static inline void nrfx_delay_cycles(uint32_t cycles) {
  uint32_t cyccnt_initial = DWT->CYCCNT;
  cyccnt_initial = DWT->CYCCNT;
  while ((DWT->CYCCNT - cyccnt_initial) < cycles) {
  }
}

const static int ws2812_rtio_iodev_write(
    const struct device *dev, struct led_rgb *pixels
) {
  const struct ws2812_rtio_config *config = dev->config;
  size_t bit = 0;
  uint8_t *ptr = (uint8_t *)pixels;
  size_t len = config->chain_length;
  // const struct device *port = config->gpios.port;
  gpio_port_pins_t pin = (gpio_port_pins_t)BIT(config->gpios.pin);

  volatile uint32_t *set = (uint32_t *)&NRF_P0->OUTSET;
  volatile uint32_t *clear = (uint32_t *)&NRF_P0->OUTCLR;

  LOG_DBG("bit_val = %i", *(ptr));
  uint8_t bit_val = *(ptr++);

  // Save the current state of the DEMCR register to be able to restore it
  // before exiting this function. Enable the trace and debug blocks (including
  // DWT).
  uint32_t core_debug = CoreDebug->DEMCR;
  CoreDebug->DEMCR = core_debug | CoreDebug_DEMCR_TRCENA_Msk;

  // Save the current state of the CTRL register in the DWT block. Make sure
  // that the cycle counter is enabled.
  uint32_t dwt_ctrl = DWT->CTRL;
  DWT->CTRL = dwt_ctrl | DWT_CTRL_CYCCNTENA_Msk;

  uint32_t key = irq_lock();

  while (len--) {
    for (bit = 0; bit < 8; bit++) {
      // barrier_dsync_fence_full();
      if ((0b10000000 >> bit) & (bit_val)) {
        LOGIC_HIGH(set, pin);
        DELAY_T1H;
        // nrfx_delay_cycles(16);
        LOGIC_LOW(clear, pin);
        DELAY_T0H;
        // nrfx_delay_cycles(1);
        // gpio_port_set_bits_raw(port, pin);
        // gpio_port_set_bits_raw(port, pin);
        // gpio_port_clear_bits_raw(port, pin);

      } else {
        LOGIC_HIGH(set, pin);
        // nrfx_delay_cycles(2);
        DELAY_T0H;
        LOGIC_LOW(clear, pin);
        // nrfx_delay_cycles(16);
        DELAY_T1H;
        // gpio_port_set_bits_raw(port, pin);
        // gpio_port_clear_bits_raw(port, pin);
        // gpio_port_clear_bits_raw(port, pin);
      }
    }
  }

  // Restore preserved registers.
  DWT->CTRL = dwt_ctrl;
  CoreDebug->DEMCR = core_debug;
  irq_unlock(key);
  return 0;
}

static void ws2812_rtio_iodev_execute(
    const struct device *dev, struct rtio_iodev_sqe *iodev_sqe,
    struct led_rgb *pixels
) {
  LOG_DBG("Entering ws2812_rtio_iodev_execute");
  // const struct ws2812_rtio_config *config = dev->config;
  int result;

  if (iodev_sqe->sqe.op == RTIO_OP_TX) {
    result = ws2812_rtio_iodev_write(dev, pixels);
  } else {
    LOG_ERR("%s: Invalid op", dev->name);
    result = -EINVAL;
  }

  if (result < 0) {
    rtio_iodev_sqe_err(iodev_sqe, result);
  } else {
    rtio_iodev_sqe_ok(iodev_sqe, result);
  }
}

static void ws2812_rtio_iodev_submit(struct rtio_iodev_sqe *iodev_sqe) {
  LOG_DBG("Entering ws2812_rtio_iodev_submit");
  struct ws2812_rtio_data *data =
      (struct ws2812_rtio_data *)iodev_sqe->sqe.iodev;

  rtio_mpsc_push(&data->iodev.iodev_sq, &iodev_sqe->q);
}

static void ws2812_rtio_handle_int(const struct device *dev) {
  LOG_DBG("Entering ws2812_rtio_handle_int");
  struct ws2812_rtio_data *data = dev->data;
  const struct ws2812_rtio_config *config = dev->config;
  struct rtio_mpsc_node *node = rtio_mpsc_pop(&data->iodev.iodev_sq);
  struct led_rgb pixels[config->chain_length];

  if (node != NULL) {
    struct rtio_iodev_sqe *iodev_sqe =
        CONTAINER_OF(node, struct rtio_iodev_sqe, q);

    ws2812_rtio_update_rgb(dev, pixels);

    ws2812_rtio_iodev_execute(dev, iodev_sqe, pixels);
  } else {
    LOG_ERR("%s: Could not get a msg", dev->name);

    /* FOR DEBUGGING ONLY*/
    exit(1);
  }
}

static void ws2812_rtio_timer_expiry(struct k_timer *timer) {
  LOG_DBG("Entering ws2812_rtio_timer_expiry");
  struct ws2812_rtio_data *data =
      CONTAINER_OF(timer, struct ws2812_rtio_data, timer);

  ws2812_rtio_handle_int(data->dev);
}

// static int ws2812_rtio_update_channels(
//     const struct device *dev, uint8_t *channels, size_t num_channels
// ) {
//   LOG_ERR("update_channels not implemented");
//   return -ENOTSUP;
// }

// static const struct led_strip_driver_api ws2812_rtio_api = {
//     .update_rgb = ws2812_rtio_update_rgb,
//     .update_channels = ws2812_rtio_update_channels
// };

static const struct rtio_iodev_api ws2812_rtio_iodev_api = {
    .submit = ws2812_rtio_iodev_submit,
};

static int ws2812_rtio_init(const struct device *dev) {
  LOG_DBG("Entering ws2812_rtio_init");
  const struct ws2812_rtio_config *config = dev->config;
  struct ws2812_rtio_data *data = dev->data;
  int err = 0;
  uint8_t c;

  if (!gpio_is_ready_dt(&config->gpios)) {
    LOG_ERR("GPIO device not ready");
    return -ENODEV;
  }

  err = gpio_pin_configure_dt(&config->gpios, GPIO_OUTPUT);
  if (err) {
    LOG_ERR("Failed to configure gpio");
    return err;
  }

  for (c = 0; c < config->num_colors; c++) {
    switch (config->color_mapping[c]) {
      case LED_COLOR_ID_WHITE:
      case LED_COLOR_ID_RED:
      case LED_COLOR_ID_GREEN:
      case LED_COLOR_ID_BLUE:
        break;
      default:
        LOG_ERR(
            "%s: invalid channel to color mapping."
            " Check the color-mapping DT property",
            dev->name
        );
        return -EINVAL;
    }
  }

  // Start accurate HFCLK (XOSC)
  // NRF_CLOCK->TASKS_HFCLKSTART = 1;
  // LOG_WRN("HFCLK started");

  data->dev = dev;
  // data->num_pixels = config->chain_length;
  // data->num_pixels = config->chain_length * config->num_colors;
  LOG_DBG("num_pixels: %i", config->chain_length);

  // LOG_WRN("MHz: %i", timing_freq_get_mhz());

  rtio_mpsc_init(&data->iodev.iodev_sq);
  k_timer_init(&data->timer, ws2812_rtio_timer_expiry, NULL);
  k_timer_start(&data->timer, K_MSEC(15), K_TIMEOUT_ABS_CYC(1));

  return 0;
}

/*
 * Retrieve the channel to color mapping (e.g. RGB, BGR, GRB, ...) from the
 * "color-mapping" DT property.
 */
#define WS2812_COLOR_MAPPING(idx)                            \
  static const uint8_t ws2812_rtio_##idx##_color_mapping[] = \
      DT_INST_PROP(idx, color_mapping)

#define WS2812_NUM_COLORS(idx) (DT_INST_PROP_LEN(idx, color_mapping))

#define WS2812_RTIO_DEVICE(idx)                                         \
  WS2812_COLOR_MAPPING(idx);                                            \
                                                                        \
  static const struct ws2812_rtio_config ws2812_rtio_##idx##_config = { \
      .gpios = GPIO_DT_SPEC_INST_GET(idx, gpios),                       \
      .num_colors = WS2812_NUM_COLORS(idx),                             \
      .color_mapping = ws2812_rtio_##idx##_color_mapping,               \
      .chain_length = DT_INST_PROP(idx, chain_length)                   \
  };                                                                    \
                                                                        \
  static struct ws2812_rtio_data ws2812_rtio_##idx##_data = {           \
      .iodev =                                                          \
          {                                                             \
              .api = &ws2812_rtio_iodev_api,                            \
          },                                                            \
  };                                                                    \
                                                                        \
  DEVICE_DT_INST_DEFINE(                                                \
      idx, ws2812_rtio_init, NULL, &ws2812_rtio_##idx##_data,           \
      &ws2812_rtio_##idx##_config, POST_KERNEL,                         \
      CONFIG_KERNEL_INIT_PRIORITY_DEVICE, NULL                          \
  );

DT_INST_FOREACH_STATUS_OKAY(WS2812_RTIO_DEVICE)
